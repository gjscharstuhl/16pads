desc:GJS_Drums
config:group "Group"  1 1 2 3 4

<?
printf("options:gmem=16pads%d",group;);

?>

import gfx.jsfx-inc
import tools.jsfx-inc
import globalinit.jsfx-inc



slider1:tchannel=1;<1,16,1>Channel
slider2:tlev=0;<0,7,1>Level


@init
ext_noinit = 1.0; // not with playback

function logb(x, base) ( log(x)/log(base) );


function init()
(
//config();
lev=0;
ini+=1;
precisie=2;
loaded=0;
record=0;
recorded=0;
recording=0;
gorecording=0;
recordingdone=0;
noteOn = $x90;
noteOff = $x80;

chid=750;
sloaded=760;
loadfase=770;
handle=780;

//midinote=100;
pad_id=500;
pad_note=500+16*1;

layers=8;
bufstart=3000;
bufsize=(__memtop()-bufstart)/8;

buflength=bufsize;
samplelength=0;
bufpos=bufstart;
samplestart=bufstart;
sampleend=bufstart;

notesstart=1000;
notenr=notesstart;
notevel=notesstart+128;
notestate=notesstart+128*2;
notebuf=notesstart+128*3;
enva=notesstart+128*4;
envd=notesstart+128*5;
envs=notesstart+128*6;
envr=notesstart+128*7;
recordingknob.event=0;
recordedknob.event=0;

mystack=0;
fname=1;
f=0;
offset=0;
octavecor=logb(1/precisie,2)*12;



//init_sample_data_defaults();
//load_from_dropped(bufstart);
);


function getnote(nr)
(
    this.nr=notenr[nr];
    this.vel=notevel[nr];
    this.state=notestate[nr];
    this.buf=notebuf[nr];
    this.a=enva[nr];
    this.d=envd[nr];
    this.s=envs[nr];
    this.r=envr[nr];
    
);


function writenote(nr,vel,state,buf,a,d,s,r)
(
  notenr[nr]=nr;
  notevel[nr]=vel;
  notestate[nr]=state;state==noteOff ? noteofftest=1;
  notebuf[nr]=buf;
  enva[nr]=a;
  envd[nr]=d;
  envs[nr]=s;//slider4/100;
  envr[nr]=r;
);


function adsr()
(
  level=gmem[padlevel+tchannel];
  this.a<1 ? this.a+=(1/srate/gmem[env_a+(tchannel*16)+level]*1000);
  this.a>1 ? this.a=1;
  this.a==1 && this.d>gmem[env_s+(tchannel*16)+level]  
    ? this.d-=1/srate/gmem[env_d+(tchannel*16)+level]*1000;

  this.state==noteOff ? ( this.r-=1/srate/gmem[env_r+(tchannel*16)+level]*1000;);
  this.r<0 ? this.r=0;
  //this.d=1;this.s=1;
  vol=gmem[sampvol+(tchannel*16)+level];
  this.vol=vol*this.a*this.r*this.d*this.r*this.vel/127;

);


init();

@serialize
 
@slider

@block

function getlevel(vel,level*)
local(mode,samplelamount,levelborder)
(
  
  mode=gmem[gpadmode+tchannel];
  zzz1=mode;
  sampleamount=gmem[gsampleamount+tchannel];
  
  mode==1 ? (level=gmem[padlevel+tchannel];): //level
  mode==2 ? ( // velocity
    levelborder=127/(sampleamount);
    level=0;;
    loop(sampleamount,
      vel>levelborder*(level+1) ? (level+=1);
    );
   
  ): 
  mode==3 ? ( // random
    level=floor(rand(sampleamount));
  
  ):
  mode==4 ? (
    level=(level+1)%sampleamount;
    // todo
  ):
  mode=5 ? (
    0;
  );
  level;

);


while (midirecv(boffset,msg1,msg2,msg3)) ( 
    gmem[midinote+tchannel] == msg2 ? (
    channel = msg1 & $x0F;
    onOffStatus = msg1 & $xF0; // 144 == Note On, 128 == Note Off

    trigTest = noteTrig == 0 ? (noteOn):(noteOff); // comparison value based on our note on/off setting

    notenrblock=msg2;xxw3=msg2;
    channel == inChannel  ? (
        trigTest == onOffStatus ? (
            freq=440*2^((msg2-rootnote)/12);
            vel=msg3;
            lev=getlevel(msg3,lev);
            
            //lev=gmem[padlevel+tchannel];
            samplestart=(gmem[lp1+(16*tchannel)+lev]);          

            div=2^(floor(notenrblock-rootnote+octavecor)/12);
            div=1;
            //bufpos=samplestart/div;
            bufpos=samplestart;
            inn=1;
            
            writenote(notenrblock,vel,noteOn,bufpos,0,1,sustain,1);
        ) :
        (
            
           note.getnote(notenrblock);
           writenote(note.nr,note.vel,noteOff,note.buf,note.a,note.d,note.s,note.r);
        );
        
    );
    );
    
  
  
    midisend(boffset,msg1,msg2,msg3); // pass through 
   
);


@sample
zzz10=gmem[loadpad+tchannel];


function clearlevel(level)
(
  level==0 ? #f0="":
  level==1 ? #f1="":
  level==2 ? #f2="":
  level==3 ? #f3="":
  level==4 ? #f4="":
  level==5 ? #f5="":
  level==6 ? #f6="":
  level==7 ? #f7="";
  loadfase[level]=0;
  chid[level]=0;
  sloaded[level]=0;
  _global.clearlevel=-1;
);

function getstrings()
local(level)
(
   _global.droppedonpad==tchannel ?(
   level=gmem[padlevel+tchannel];
   
   _global.clearlevel==level ?  clearlevel(level);
     
      
    
      
  gmem[padlevel+tchannel]==0 ? #f0=readstring(gfilename):
  gmem[padlevel+tchannel]==1 ? #f1=readstring(gfilename):
  gmem[padlevel+tchannel]==2 ? #f2=readstring(gfilename):
  gmem[padlevel+tchannel]==3 ? #f3=readstring(gfilename):
  gmem[padlevel+tchannel]==4 ? #f4=readstring(gfilename):
  gmem[padlevel+tchannel]==5 ? #f5=readstring(gfilename):
  gmem[padlevel+tchannel]==6 ? #f6=readstring(gfilename):
  gmem[padlevel+tchannel]==7 ? #f7=readstring(gfilename);
  zzz=gmem[padlevel+tchannel];
  gmem[loadpad+tchannel]=0;
  //#f0="E:/music/test/mpdjam/solo1.wav";
  //#f1="E:/music/test/mpdjam/solo2.wav";
  );

);


  getstrings();
  //str="/home/gjs/reaperprojects/test/mpdjam/solo1.wav";

  getfile3( #f0,0,tchannel);
  getfile3( #f1,1,tchannel);
  getfile3( #f2,2,tchannel);
  getfile3( #f3,3,tchannel);
  getfile3( #f4,4,tchannel);
  getfile3( #f5,5,tchannel);
  getfile3( #f6,6,tchannel);
  getfile3( #f7,7,tchannel);

  


_global.clearmem==tchannel ? (
  memset(bufstart,0,__memtop()-bufstart);
  loop(l=0;8,clearlevel(l);l+=1);
  _global.clearmem=0;
);


spll=0;
splr=0;

note.getnote(gmem[midinote+tchannel]);


note.state>0 ? 
(
  note.adsr();
  zzz3=gmem[gpadmode+tchannel];
  gmem[gpadmode+tchannel]==9 ? lev= gmem[padlevel+tchannel];
  

  gmem[gpadmode+tchannel]==5 ? // mixed mode
  (
    loop (lev=0;gmem[gsampleamount+tchannel],
      spll += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[0]*note.vol;
      splr += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[1]*note.vol;
      lev+=1;
    );
  ): // single mode
  (
    spll += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[0]*note.vol;
    splr += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[1]*note.vol;
  );
  
  spll <= 1 && spll> -1 ? (spl0=spll;);
  splr <= 1 && splr> -1 ? (spl1=splr;);
  note.buf+=2;
  level=gmem[padlevel+tchannel];
  size=gmem[lp2+(16*tchannel)+level]-gmem[lp1+(16*tchannel)+level];
  note.buf>=samplestart+size ? (
    gmem[sloop+(16*tchannel)+level]? (
      note.buf=gmem[lp1+(16*tchannel)+level];
      note.a=0;note.d=1;
     ):note.state=noteOff;
    
  );

  writenote(note.nr,note.vel,note.state,note.buf,note.a,note.d,note.s,note.r);
  
  notenrsample+=1;

);


@gfx 400 300

//memset( bufstart,1,bfs);
gdrawwav(10,10,300,150,bufstart+(bfs*tlev),bfs,0);
