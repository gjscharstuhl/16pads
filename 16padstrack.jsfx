desc:GJS_Drums
config:group "Group"  1 1 2 3 4

<?
printf("options:gmem=16pads%d",group;);

?>

import gfx.jsfx-inc
import tools.jsfx-inc
import globalinit.jsfx-inc



slider1:tchannel=1;<1,16,1>Channel
slider2:tlev=0;<0,7,1>Level



@init
ext_noinit = 1.0; // not with playback

function logb(x, base) ( log(x)/log(base) );


function init()
(
//config();
zzz13=0;
lev=0;
ini+=1;
precisie=2;
loaded=0;
record=0;
recorded=0;
recording=0;
gorecording=0;
recordingdone=0;
noteOn = $x90;
noteOff = $x80;

chid=750;
sloaded=760;
loadfase=770;
handle=780;

//midinote=100;
pad_id=500;
pad_note=500+16*1;

layers=8;
bufstart=3000;
bufsize=(__memtop()-bufstart)/8;

buflength=bufsize;
samplelength=0;
bufpos=bufstart;
samplestart=bufstart;
sampleend=bufstart;

notesstart=1000;
notenr=notesstart;
notevel=notesstart+128;
notestate=notesstart+128*2;
notebuf=notesstart+128*3;
enva=notesstart+128*4;
envd=notesstart+128*5;
envs=notesstart+128*6;
envr=notesstart+128*7;
recordingknob.event=0;
recordedknob.event=0;

mystack=0;
fname=1;
f=0;
offset=0;
octavecor=logb(1/precisie,2)*12;

_global.padsloaded+=1;

//init_sample_data_defaults();
//load_from_dropped(bufstart);
);


function getnote(nr)
(
    this.nr=notenr[nr];
    this.vel=notevel[nr];
    this.state=notestate[nr];
    this.buf=notebuf[nr];
    this.a=enva[nr];
    this.d=envd[nr];
    this.s=envs[nr];
    this.r=envr[nr];
    
);


function writenote(nr,vel,state,buf,a,d,s,r)
(
  notenr[nr]=nr;
  notevel[nr]=vel;
  notestate[nr]=state;state==noteOff ? noteofftest=1;
  notebuf[nr]=buf;
  enva[nr]=a;
  envd[nr]=d;
  envs[nr]=s;//slider4/100;
  envr[nr]=r;
);


function adsr()
(
  srate == 0 ? srate=48000;
  level=gmem[padlevel+tchannel];
  this.a<1 ? this.a+=(1/srate/gmem[env_a+(tchannel*16)+level]*1000);
  this.a>1 ? this.a=1;
  this.a==1 && this.d>gmem[env_s+(tchannel*16)+level]  
    ? this.d-=1/srate/gmem[env_d+(tchannel*16)+level]*1000;

  this.state==noteOff ? ( this.r-=1/srate/gmem[env_r+(tchannel*16)+level]*1000;);
  this.r<0 ? this.r=0;
  //this.d=1;this.s=1;
  vol=gmem[sampvol+(tchannel*16)+level];
  this.vol=vol*this.a*this.r*this.d*this.r*this.vel/127;

);


function clearlevel(level)
(
  addr=40+level;
  strcpy(addr,"");
  loadfase[level]=0;
  chid[level]=0;
  sloaded[level]=0;
  level==0 ? bfs=0;
  _global.clearlevel=-1;
);





init();

@serialize
file_mem(0,bufstart,__memtop()-bufstart);
 
@slider

addr=40+tlev;
zzz11+=1;
strcpy(addr,"");
//while (strlen(addr)==0)
//(
//  strcpy(addr,readstring(gfilename));
//);


@block

function getstrings()
local(l)
(
  ready=0;
  gstr=0;
  loop(l=0;8,
    addr=40+l;strcpy(addr,"");
    l+=1;
     
  );
  zzz14=gmem[gsampleamount+tchannel];
  loop(l=0;8,
    addr=40+l;addrold=50+l;
    strcpy(#f,"");
    strcpy(addr,"");
    while (strlen(#f)==0)(
      #f=readstring(gfilename+(tchannel*255*16)+(l*255));
      
    );
    strcpy(addr,#f);

    loadfase[l]=0;
    bfs=0;
    l+=1;
  );
  ready=1;
);

function load()
local(l,addr)
(
  l=0;
  loop(8,
    addr=40+l;
    getfile3(addr,l,tchannel);
    l+=1;
  
  );
  
);

function getlevel(vel,level*)
local(mode,samplelamount,levelborder)
(
  
  mode=gmem[gpadmode+tchannel];
  zzz1=mode;
  sampleamount=gmem[gsampleamount+tchannel];
  
  mode==1 ? (level=gmem[padlevel+tchannel];): //level
  mode==2 ? ( // velocity
    levelborder=127/(sampleamount);
    level=0;;
    loop(sampleamount,
      vel>levelborder*(level+1) ? (level+=1);
    );
   
  ): 
  mode==3 ? ( // random
    level=floor(rand(sampleamount));
  
  ):
  mode==4 ? (
    level=(level+1)%sampleamount;
    // todo
  ):
  mode=5 ? (
    0;
  );
  level;

);


while (midirecv(boffset,msg1,msg2,msg3)) ( 
    gmem[midinote+tchannel] == msg2 ? (
    channel = msg1 & $x0F;
    onOffStatus = msg1 & $xF0; // 144 == Note On, 128 == Note Off

    trigTest = noteTrig == 0 ? (noteOn):(noteOff); // comparison value based on our note on/off setting

    notenrblock=msg2;xxw3=msg2;
    channel == inChannel  ? (
        trigTest == onOffStatus ? (
            freq=440*2^((msg2-rootnote)/12);
            vel=msg3;
            lev=getlevel(msg3,lev);
            
            //lev=gmem[padlevel+tchannel];
            samplestart=(gmem[lp1+(16*tchannel)+lev]);          

            div=2^(floor(notenrblock-rootnote+octavecor)/12);
            div=1;
            //bufpos=samplestart/div;
            bufpos=samplestart;
            inn=1;
            
            writenote(notenrblock,vel,noteOn,bufpos,0,1,sustain,1);
        ) :
        (
            
           note.getnote(notenrblock);
           writenote(note.nr,note.vel,noteOff,note.buf,note.a,note.d,note.s,note.r);
        );
        
    );
    );
    
  
  
    midisend(boffset,msg1,msg2,msg3); // pass through 
   
);


gmem[loadpad+tchannel]==tchannel ?(getstrings(););
ready ? load();
//getstrings();
//zzz11=gmem[gsampleamount+tchannel];
//loop (lve=0;gmem[gsampleamount+tchannel],
//  addr=40+lve;
//  strlen(addr)>0 ?getfile3(addr,lve,tchannel);
//  lve+=1;

// ready=0;

  
@sample



  




spll=0;
splr=0;

note.getnote(gmem[midinote+tchannel]);


note.state>0 ? 
(
  note.adsr();
  zzz3=gmem[gpadmode+tchannel];
  gmem[gpadmode+tchannel]==9 ? lev= gmem[padlevel+tchannel];
  

  gmem[gpadmode+tchannel]==5 ? // mixed mode
  (
    loop (lev=0;gmem[gsampleamount+tchannel],
      spll += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[0]*note.vol;
      splr += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[1]*note.vol;
      lev+=1;
    );
  ): // single mode
  (
    spll += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[0]*note.vol;
    splr += (bufstart+(lev*gmem[gbufsize+tchannel])+note.buf)[1]*note.vol;
  );
  
  spll <= 1 && spll> -1 ? (spl0=spll;);
  splr <= 1 && splr> -1 ? (spl1=splr;);
  note.buf+=2;
  level=gmem[padlevel+tchannel];
  size=gmem[lp2+(16*tchannel)+level]-gmem[lp1+(16*tchannel)+level];
  note.buf>=samplestart+size ? (
    gmem[sloop+(16*tchannel)+level]? (
      note.buf=gmem[lp1+(16*tchannel)+level];
      note.a=0;note.d=1;
     ):note.state=noteOff;
    
  );

  writenote(note.nr,note.vel,note.state,note.buf,note.a,note.d,note.s,note.r);
  
  notenrsample+=1;

);


@gfx 400 300

//memset( bufstart,1,bfs);
gdrawwav(10,10,300,150,bufstart+(bfs*tlev),bfs,0);
